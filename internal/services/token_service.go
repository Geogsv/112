package services

import (
	// Стандартные библиотеки
	"crypto/rand"     // Пакет для доступа к криптографически стойким генераторам случайных чисел
	"encoding/base64" // Пакет для кодирования/декодирования данных в Base64
	"fmt"             // Для форматирования ошибок
	"log"
)

// GenerateSecureToken генерирует криптографически стойкую случайную строку
// указанной длины (в байтах). Результат кодируется в URL-safe Base64 без символов '='.
//
// Параметры:
//   length - желаемое количество случайных байт для генерации токена.
//            Длина результирующей строки будет примерно length * 4 / 3 символов.
//
// Возвращает:
//   Сгенерированную токен-строку и ошибку (nil в случае успеха).
func GenerateSecureToken(length int) (string, error) {
	// 1. Создаем срез байт нужной длины.
	b := make([]byte, length)

	// 2. Читаем случайные байты из криптографически надежного источника операционной системы.
	//    rand.Read заполняет переданный срез байт случайными данными.
	_, err := rand.Read(b)
	if err != nil {
		// Если ОС не может предоставить случайные данные (очень редкая и серьезная проблема),
		// возвращаем ошибку. Нельзя генерировать токены без надежного источника случайности.
		log.Printf("КРИТИЧЕСКАЯ ОШИБКА: Не удалось прочитать случайные байты из crypto/rand: %v", err)
		return "", fmt.Errorf("не удалось сгенерировать случайные байты для токена: %w", err)
	}

	// 3. Кодируем сгенерированные случайные байты в строку Base64.
	//    Используем RawURLEncoding:
	//    - URL-safe: Заменяет стандартные символы '+' и '/' на '-' и '_' соответственно,
	//      что делает строку безопасной для использования в URL без дополнительного кодирования.
	//    - Raw: Опускает символы заполнения '=' в конце строки, делая ее короче и чище.
	token := base64.RawURLEncoding.EncodeToString(b)

	// Возвращаем сгенерированную строку токена и nil ошибку.
	return token, nil
}